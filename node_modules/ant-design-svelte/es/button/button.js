/* generated by Svelte v3.6.5 */
import {
	SvelteComponent,
	append,
	assign,
	bubble,
	check_outros,
	children,
	claim_element,
	claim_text,
	create_slot,
	destroy_component,
	detach,
	element,
	empty,
	exclude_internal_props,
	get_slot_changes,
	get_slot_context,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	set_attributes,
	space,
	transition_in,
	transition_out
} from "svelte/internal";
import wave from "../_util/wave";
import classNames from "../_util/classes";
import Icon from "../icon";
import tooltip from "../tooltip";

// (60:0) {:else}
function create_else_block_1(ctx) {
	var button, t, current_block_type_index, if_block1, wave_action, tooltip_action, current, dispose;

	var if_block0 = (ctx.iconType) && create_if_block_4(ctx);

	var if_block_creators = [
		create_if_block_3,
		create_else_block_2
	];

	var if_blocks = [];

	function select_block_type_2(ctx) {
		if (ctx.havSlot) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	var button_levels = [
		ctx.buttonProps,
		{ type: ctx.htmlType || 'button' }
	];

	var button_data = {};
	for (var i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = element("button");
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			this.h()
		},

		l(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true }, false);
			var button_nodes = children(button);

			if (if_block0) if_block0.l(button_nodes);
			t = claim_text(button_nodes, "\n    ");
			if_block1.l(button_nodes);
			button_nodes.forEach(detach);
			this.h();
		},

		h() {
			set_attributes(button, button_data);
			dispose = listen(button, "click", ctx.click_handler_1);
		},

		m(target_1, anchor) {
			insert(target_1, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append(button, t);
			if_blocks[current_block_type_index].m(button, null);
			wave_action = wave.call(null, button, ctx.type !== 'link') || {};
			tooltip_action = tooltip.call(null, button, ctx.tooltipConfig) || {};
			current = true;
		},

		p(changed, ctx) {
			if (ctx.iconType) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block1 = if_blocks[current_block_type_index];
				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}
				transition_in(if_block1, 1);
				if_block1.m(button, null);
			}

			set_attributes(button, get_spread_update(button_levels, [
				(changed.buttonProps) && ctx.buttonProps,
				(changed.htmlType) && { type: ctx.htmlType || 'button' }
			]));

			if (typeof wave_action.update === 'function' && changed.type) {
				wave_action.update.call(null, ctx.type !== 'link');
			}

			if (typeof tooltip_action.update === 'function' && changed.tooltipConfig) {
				tooltip_action.update.call(null, ctx.tooltipConfig);
			}
		},

		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},

		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if (wave_action && typeof wave_action.destroy === 'function') wave_action.destroy();
			if (tooltip_action && typeof tooltip_action.destroy === 'function') tooltip_action.destroy();
			dispose();
		}
	};
}

// (47:0) {#if href}
function create_if_block(ctx) {
	var a, t, current_block_type_index, if_block1, tooltip_action, current, dispose;

	var if_block0 = (ctx.iconType) && create_if_block_2(ctx);

	var if_block_creators = [
		create_if_block_1,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type_1(ctx) {
		if (ctx.havSlot) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	var a_levels = [
		ctx.buttonProps,
		{ href: ctx.href },
		{ target: ctx.target }
	];

	var a_data = {};
	for (var i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			this.h()
		},

		l(nodes) {
			a = claim_element(nodes, "A", { href: true, target: true }, false);
			var a_nodes = children(a);

			if (if_block0) if_block0.l(a_nodes);
			t = claim_text(a_nodes, "\n    ");
			if_block1.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},

		h() {
			set_attributes(a, a_data);
			dispose = listen(a, "click", ctx.click_handler);
		},

		m(target_1, anchor) {
			insert(target_1, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append(a, t);
			if_blocks[current_block_type_index].m(a, null);
			tooltip_action = tooltip.call(null, a, ctx.tooltipConfig) || {};
			current = true;
		},

		p(changed, ctx) {
			if (ctx.iconType) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block1 = if_blocks[current_block_type_index];
				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}
				transition_in(if_block1, 1);
				if_block1.m(a, null);
			}

			set_attributes(a, get_spread_update(a_levels, [
				(changed.buttonProps) && ctx.buttonProps,
				(changed.href) && { href: ctx.href },
				(changed.target) && { target: ctx.target }
			]));

			if (typeof tooltip_action.update === 'function' && changed.tooltipConfig) {
				tooltip_action.update.call(null, ctx.tooltipConfig);
			}
		},

		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},

		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(a);
			}

			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if (tooltip_action && typeof tooltip_action.destroy === 'function') tooltip_action.destroy();
			dispose();
		}
	};
}

// (67:4) {#if iconType}
function create_if_block_4(ctx) {
	var current;

	var icon_1 = new Icon({ props: { type: ctx.iconType } });

	return {
		c() {
			icon_1.$$.fragment.c();
		},

		l(nodes) {
			icon_1.$$.fragment.l(nodes);
		},

		m(target_1, anchor) {
			mount_component(icon_1, target_1, anchor);
			current = true;
		},

		p(changed, ctx) {
			var icon_1_changes = {};
			if (changed.iconType) icon_1_changes.type = ctx.iconType;
			icon_1.$set(icon_1_changes);
		},

		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);

			current = true;
		},

		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},

		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (74:4) {:else}
function create_else_block_2(ctx) {
	var current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target_1, anchor) {
			if (default_slot) {
				default_slot.m(target_1, anchor);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (70:4) {#if havSlot}
function create_if_block_3(ctx) {
	var span, current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			span = element("span");

			if (default_slot) default_slot.c();
		},

		l(nodes) {
			span = claim_element(nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach);
		},

		m(target_1, anchor) {
			insert(target_1, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(span);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (49:4) {#if iconType}
function create_if_block_2(ctx) {
	var current;

	var icon_1 = new Icon({ props: { type: ctx.iconType } });

	return {
		c() {
			icon_1.$$.fragment.c();
		},

		l(nodes) {
			icon_1.$$.fragment.l(nodes);
		},

		m(target_1, anchor) {
			mount_component(icon_1, target_1, anchor);
			current = true;
		},

		p(changed, ctx) {
			var icon_1_changes = {};
			if (changed.iconType) icon_1_changes.type = ctx.iconType;
			icon_1.$set(icon_1_changes);
		},

		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);

			current = true;
		},

		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},

		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (56:4) {:else}
function create_else_block(ctx) {
	var current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target_1, anchor) {
			if (default_slot) {
				default_slot.m(target_1, anchor);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (52:4) {#if havSlot}
function create_if_block_1(ctx) {
	var span, current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			span = element("span");

			if (default_slot) default_slot.c();
		},

		l(nodes) {
			span = claim_element(nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach);
		},

		m(target_1, anchor) {
			insert(target_1, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(span);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block,
		create_else_block_1
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.href) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},

		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m(target_1, anchor) {
			if_blocks[current_block_type_index].m(target_1, anchor);
			insert(target_1, if_block_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o(local) {
			transition_out(if_block);
			current = false;
		},

		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

let hasTwoCNChar = false;

function instance($$self, $$props, $$invalidate) {
	
  let { tooltip: tooltipConfig, prefixCls = "ant-btn", type = "default", htmlType = "button", icon = "", shape, size = "default", loading, disabled, ghost, block, href, target } = $$props;
  let sizeMap = {
    large: "lg",
    small: "sm"
  };

  let havSlot = !!$$props.$$slots;

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props))
		if ('tooltip' in $$new_props) $$invalidate('tooltipConfig', tooltipConfig = $$new_props.tooltip);
		if ('prefixCls' in $$new_props) $$invalidate('prefixCls', prefixCls = $$new_props.prefixCls);
		if ('type' in $$new_props) $$invalidate('type', type = $$new_props.type);
		if ('htmlType' in $$new_props) $$invalidate('htmlType', htmlType = $$new_props.htmlType);
		if ('icon' in $$new_props) $$invalidate('icon', icon = $$new_props.icon);
		if ('shape' in $$new_props) $$invalidate('shape', shape = $$new_props.shape);
		if ('size' in $$new_props) $$invalidate('size', size = $$new_props.size);
		if ('loading' in $$new_props) $$invalidate('loading', loading = $$new_props.loading);
		if ('disabled' in $$new_props) $$invalidate('disabled', disabled = $$new_props.disabled);
		if ('ghost' in $$new_props) $$invalidate('ghost', ghost = $$new_props.ghost);
		if ('block' in $$new_props) $$invalidate('block', block = $$new_props.block);
		if ('href' in $$new_props) $$invalidate('href', href = $$new_props.href);
		if ('target' in $$new_props) $$invalidate('target', target = $$new_props.target);
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	let buttonProps, iconType;

	$$self.$$.update = ($$dirty = { disabled: 1, prefixCls: 1, type: 1, shape: 1, sizeMap: 1, size: 1, loading: 1, ghost: 1, block: 1, icon: 1 }) => {
		if ($$dirty.disabled || $$dirty.prefixCls || $$dirty.type || $$dirty.shape || $$dirty.sizeMap || $$dirty.size || $$dirty.loading || $$dirty.ghost || $$dirty.block) { $$invalidate('buttonProps', buttonProps = {
        disabled,
        class: classNames({
          [`${prefixCls}`]: true,
          [`${prefixCls}-${type}`]: type,
          [`${prefixCls}-${shape}`]: shape,
          [`${prefixCls}-${sizeMap[size]}`]: sizeMap[size],
          // [`${prefixCls}-icon-only`]: !children && children !== 0 && icon,
          [`${prefixCls}-loading`]: loading,
          [`${prefixCls}-background-ghost`]: ghost || type === "ghost",
          // [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar,
          [`${prefixCls}-block`]: block
        })
      }); }
		if ($$dirty.loading || $$dirty.icon) { $$invalidate('iconType', iconType = loading ? "loading" : icon); }
	};

	return {
		tooltipConfig,
		prefixCls,
		type,
		htmlType,
		icon,
		shape,
		size,
		loading,
		disabled,
		ghost,
		block,
		href,
		target,
		havSlot,
		buttonProps,
		iconType,
		click_handler,
		click_handler_1,
		$$props: $$props = exclude_internal_props($$props),
		$$slots,
		$$scope
	};
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, ["tooltip", "prefixCls", "type", "htmlType", "icon", "shape", "size", "loading", "disabled", "ghost", "block", "href", "target"]);
	}
}

export default Component;